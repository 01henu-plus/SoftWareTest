# SQL 注入安全测试报告

## 测试信息
- **测试日期**: 2025年11月19日
- **测试工具**: Python + Flask + Selenium/浏览器测试
- **测试对象**: 登录接口 SQL 注入漏洞检测
- **测试浏览器**: Google Chrome

## 测试环境
- **Python 版本**: 3.14.0
- **Flask 版本**: 3.1.2
- **数据库**: SQLite3
- **操作系统**: Windows

## 项目文件
1. `app.py` - 存在 SQL 注入漏洞的 Flask 登录系统（仅用于演示）
2. `test_sql_injection.py` - SQL 注入自动化测试脚本
3. `users.db` - SQLite 数据库文件
4. `README.md` - 项目说明文档

## 测试用例设计

### 测试用例 1: 正常登录验证
**目的**: 验证系统正常登录功能

**测试数据**:
```json
{
  "username": "admin",
  "password": "admin123"
}
```

**预期结果**: 返回 200 状态码，登录成功

**实际执行的 SQL**:
```sql
SELECT * FROM users WHERE username='admin' AND password='admin123'
```

**测试结果**: ✅ **通过** - 正常登录功能正常工作

---

### 测试用例 2: SQL 注入攻击 - OR 1=1
**目的**: 测试系统是否存在 SQL 注入漏洞

**测试数据**:
```json
{
  "username": "' OR 1=1 --",
  "password": "xxx"
}
```

**攻击原理**:
- 输入的用户名 `' OR 1=1 --` 会闭合原有的单引号
- `OR 1=1` 使 WHERE 条件永远为真
- `--` 是 SQL 注释符，注释掉后面的密码验证

**实际执行的 SQL**:
```sql
SELECT * FROM users WHERE username='' OR 1=1 --' AND password='xxx'
-- 等价于: SELECT * FROM users WHERE username='' OR 1=1
```

**测试结果**: ❌ **漏洞确认** - SQL 注入攻击成功，绕过了身份验证！

**安全影响**: 
- 攻击者可以在不知道密码的情况下登录任意账户
- 可能导致数据泄露、未授权访问等严重安全问题

---

### 测试用例 3: 错误凭据验证
**目的**: 验证系统对错误凭据的处理

**测试数据**:
```json
{
  "username": "admin",
  "password": "wrongpassword"
}
```

**预期结果**: 返回 400 状态码，提示用户名或密码错误

**实际执行的 SQL**:
```sql
SELECT * FROM users WHERE username='admin' AND password='wrongpassword'
```

**测试结果**: ✅ **通过** - 正确拒绝了错误的登录凭据

---

### 测试用例 4: SQL 注入攻击 - 注释绕过
**目的**: 测试另一种 SQL 注入攻击方式

**测试数据**:
```json
{
  "username": "admin' --",
  "password": "anything"
}
```

**攻击原理**:
- 用户名 `admin' --` 先闭合单引号
- `--` 注释掉后面的所有内容，包括密码验证

**实际执行的 SQL**:
```sql
SELECT * FROM users WHERE username='admin' --' AND password='anything'
-- 等价于: SELECT * FROM users WHERE username='admin'
```

**测试结果**: ❌ **漏洞确认** - 成功绕过密码验证，直接以 admin 身份登录！

---

## 漏洞分析

### 漏洞代码定位

**文件**: `app.py` - 第 65-67 行

```python
# 危险代码 - 直接拼接用户输入
query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
cursor.execute(query)
```

### 漏洞成因

1. **字符串拼接**: 使用 f-string 直接将用户输入拼接到 SQL 语句中
2. **缺少输入验证**: 未对用户输入进行任何过滤或转义
3. **未使用参数化查询**: 没有使用数据库的参数绑定机制

### 漏洞严重程度

**严重等级**: 🔴 **严重 (Critical)**

**CVSS 评分**: 9.8 (满分 10.0)

**影响范围**:
- ✗ 未授权访问
- ✗ 数据泄露风险
- ✗ 权限提升
- ✗ 数据库完整性威胁

---

## 浏览器测试

### Chrome 浏览器测试步骤

1. **启动服务器**: 访问 http://127.0.0.1:5000
2. **打开开发者工具**: 按 F12
3. **在 Console 中执行测试代码**:

```javascript
// 测试 SQL 注入
fetch('http://127.0.0.1:5000/login', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({
    username: "' OR 1=1 --",
    password: "xxx"
  })
})
.then(r => r.json())
.then(data => {
  console.log('响应:', data);
  if (data.status === 'success') {
    console.log('⚠️ 漏洞确认: SQL 注入成功！');
  }
});
```

### Chrome 测试结果

- ✅ 页面成功加载
- ✅ API 接口可正常访问
- ❌ SQL 注入攻击成功执行
- ❌ 系统返回敏感数据

---

## 安全修复方案

### 方案 1: 使用参数化查询（推荐）⭐⭐⭐⭐⭐

```python
# 安全的代码
query = "SELECT * FROM users WHERE username=? AND password=?"
cursor.execute(query, (username, password))
```

**优点**:
- ✓ 完全防止 SQL 注入
- ✓ 数据库自动处理转义
- ✓ 性能更好（可复用执行计划）

---

### 方案 2: 输入验证和过滤 ⭐⭐⭐⭐

```python
import re

def validate_input(input_str):
    """只允许字母、数字和下划线"""
    if not re.match("^[a-zA-Z0-9_]+$", input_str):
        raise ValueError("Invalid input detected")
    return input_str

# 使用验证
username = validate_input(data.get('username', ''))
password = validate_input(data.get('password', ''))
```

**优点**:
- ✓ 阻止特殊字符注入
- ✓ 额外的安全层

**缺点**:
- ✗ 可能过于严格，影响用户体验
- ✗ 不如参数化查询彻底

---

### 方案 3: 使用 ORM 框架 ⭐⭐⭐⭐⭐

```python
from flask_sqlalchemy import SQLAlchemy

# 使用 SQLAlchemy ORM
user = User.query.filter_by(
    username=username, 
    password=password
).first()
```

**优点**:
- ✓ 自动防止 SQL 注入
- ✓ 代码更简洁易维护
- ✓ 支持多种数据库

---

### 方案 4: WAF 防护 ⭐⭐⭐

部署 Web 应用防火墙，如：
- ModSecurity
- AWS WAF
- Cloudflare WAF

**优点**:
- ✓ 提供额外防护层
- ✓ 可检测和阻止常见攻击模式

**缺点**:
- ✗ 不应作为唯一防护手段
- ✗ 可能误报

---

## 测试统计

| 测试项 | 总数 | 通过 | 失败 | 通过率 |
|--------|------|------|------|--------|
| 功能测试 | 2 | 2 | 0 | 100% |
| 安全测试 | 2 | 0 | 2 | 0% |
| **总计** | **4** | **2** | **2** | **50%** |

### 漏洞统计

| 漏洞类型 | 数量 | 严重程度 |
|----------|------|----------|
| SQL 注入 | 2 | Critical |

---

## 修复建议优先级

### 🔴 P0 - 紧急（立即修复）
1. **实施参数化查询** - 替换所有字符串拼接的 SQL 语句
2. **输入验证** - 添加严格的输入格式验证

### 🟡 P1 - 高优先级（本周内修复）
3. **密码加密** - 使用 bcrypt 或 argon2 加密存储密码
4. **日志记录** - 记录所有登录尝试和可疑活动

### 🟢 P2 - 中优先级（本月内完成）
5. **添加 WAF** - 部署 Web 应用防火墙
6. **安全审计** - 进行全面的安全代码审查
7. **渗透测试** - 定期进行专业渗透测试

---

## 学习要点

### SQL 注入攻击原理
1. **单引号闭合**: 使用 `'` 闭合原有字符串
2. **逻辑操作**: 使用 `OR 1=1` 使条件恒真
3. **注释符**: 使用 `--` 或 `#` 注释掉后续内容
4. **联合查询**: 使用 `UNION` 获取其他表数据

### 防御措施
1. ✅ **永远不要**直接拼接用户输入到 SQL 语句
2. ✅ **始终使用**参数化查询或 ORM
3. ✅ **实施**最小权限原则
4. ✅ **添加**输入验证和过滤
5. ✅ **启用**数据库审计日志

---

## 参考资料

- [OWASP SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)
- [OWASP Top 10 2021](https://owasp.org/Top10/)
- [CWE-89: SQL Injection](https://cwe.mitre.org/data/definitions/89.html)
- [Python SQLite3 文档](https://docs.python.org/3/library/sqlite3.html)

---

## 结论

本次安全测试成功验证了目标系统存在**严重的 SQL 注入漏洞**。通过两种不同的注入方式（`' OR 1=1 --` 和 `admin' --`），均成功绕过了身份验证机制。

### 关键发现
- ❌ 系统使用字符串拼接构造 SQL 查询
- ❌ 缺少输入验证和过滤
- ❌ 未实施参数化查询
- ✅ 系统正常功能运行正常

### 修复验证计划
1. 实施参数化查询修复
2. 重新运行所有测试用例
3. 进行回归测试
4. 请第三方进行安全审计

### 教育意义
⚠️ **重要提示**: 本测试系统仅用于教学演示目的，帮助理解 SQL 注入的原理和危害。在实际开发中，**必须**使用安全的编码实践，防止此类漏洞的产生。

---

**测试人员**: GitHub Copilot  
**审核状态**: 待修复  
**报告生成时间**: 2025-11-19  
**测试浏览器**: Google Chrome
